/* # Course: IoT and Edge Computing: Oct 2024
# Models and the steps to make them run on ESP32

# For other datasets that can be classified and ported on to ESP32
# Ref:https://archive.ics.uci.edu/datasets 
*/
#include <EloquentTinyML.h>
// This file has the TFlite model generated by the gliomadf_Classify_Tflite_genPy.ipynb 
#include "gliomadf_model_esp32.h"

// The glioma attribute details are given below
// Datal cols = ['Gender', 'Age_at_diagnosis', 'IDH1', 'TP53', 'ATRX', 'PTEN', 'EGFR', 'CIC', 'MUC16', 'PIK3CA', 'NF1', 'PIK3R1', 'FUBP1', 'RB1', 'NOTCH1', 'BCOR', 'CSMD3', 'SMARCA4', 'GRIN2A', 'IDH2', 'FAT4', 'PDGFRA', 'Mutations', 'Grade']
// Output Categories are: 0 (for LGG) or 1 (for GBM)

// Some sample input data and expected output from the file: gliomadf_dataset.csv
// Line no. 100: Input1 -> Output 0
// Line no. 700: Input2 -> Output 1

#define NUMBER_OF_INPUTS 23  
#define NUMBER_OF_OUTPUTS 1 

#define TENSOR_ARENA_SIZE 6*1024  // Since the size is 6936 

Eloquent::TinyML::TfLite<NUMBER_OF_INPUTS, NUMBER_OF_OUTPUTS, TENSOR_ARENA_SIZE> ml;

void setup() {
    Serial.begin(115200);
   
    ml.begin(gliomadf_model_esp32);
}

float fResult[NUMBER_OF_OUTPUTS] = {0};
float fRes = NULL;

void loop() {

// Line no. 100: Input1
    float input1[] = {0.0f ,-1.2084587209146778f ,1.0f ,0.0f ,0.0f ,
                      0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0 ,0.0f ,
                      0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,
                      0.0f ,0.0f ,-0.8732522345187961f};
// Expected output1: 0.0f

// Line no. 700: Input2
    float input2[] = {0.0f ,-0.12325404319333862f ,0.0f ,0.0f ,0.0f ,1.0f ,
                      0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,
                      0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,0.0f ,-0.8732522345187961f};
// Expected output2: 1.0f


// Line no. 419: Input3
    float input3[] = {0.0f, -0.05060969013389534f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 
                      0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 
                      0.0f, 0.0f, 0.0f, 0.0f, -0.19879566997801162f};
// Expected output3: 0.0f

// Line no. 723: Input4
    float input4[] = {0.0f, -0.6349506704453851f, 1.0f, 1.0f, 1.0f, 1.0f, 0.0f, 
                      0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 
                      0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.1501174591035572f};
// Expected output4: 1.0f

    initfResult(fResult);
    fRes = ml.predict(input1, fResult);
    Serial.print("\nThe output value returned for input1 is:\n");
    Serial.println(fRes);
    displayOutput(fResult);  

    initfResult(fResult);
    fRes = ml.predict(input2, fResult);
    Serial.print("\nThe output value returned for input2 is:\n");
    Serial.println(fRes);
    displayOutput(fResult);      
    Serial.println();

    initfResult(fResult);
    fRes = ml.predict(input3, fResult);
    Serial.print("\nThe output value returned for input3 is:\n");
    Serial.println(fRes);
    displayOutput(fResult);    
  
    initfResult(fResult);
    fRes = ml.predict(input4, fResult);
    Serial.print("\nThe output value returned for input4 is:\n");
    Serial.println(fRes);
    displayOutput(fResult);  

    delay(5000); // 5 milliseconds of delay between two plots
}

void initfResult(float *fResult){
  
    for(int i = 0; i < NUMBER_OF_OUTPUTS; i++){
       fResult[i] = 0.0f;
    }
} // end of displayOutput()

void displayOutput(float *fResult){
  
    for(int i = 0; i < NUMBER_OF_OUTPUTS; i++){
        Serial.print(fResult[i]);
        Serial.print(" ");
    }
} // end of displayOutput()
